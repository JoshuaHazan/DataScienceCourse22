---
title: "Hazan_Final_Project"
author: "Joshua Hazan"
date: "2/3/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(stats)
library(BiocGenerics)
library(DESeq2)
library(pheatmap)
# library(biomaRt)
library(BASiCS)
library(SingleCellExperiment)
library(Rtsne)
library(corrplot)
library(gprofiler2)
library(gage)

set.seed(592)

## All data was downloaded from the authors' github page at https://github.com/MarioniLab/ImmuneAging2017 (Accessed 06/02/2022) or from the ArrayExpress accession provided in the paper.
rawdata <- read.table("C:/Users/besterlab/Dropbox (Technion Dropbox)/Josh/Genome Data Science Course/Final Project/raw_data.txt", sep = "\t", header = TRUE)
normalized_counts <- read.table("C:/Users/besterlab/Dropbox (Technion Dropbox)/Josh/Genome Data Science Course/Final Project/normalized_data.txt", sep = "\t", header = TRUE)
metadata <- read.table("C:/Users/besterlab/Dropbox (Technion Dropbox)/Josh/Genome Data Science Course/Final Project/metadata.txt", sep = "\t", header = TRUE)
coldata <- column_to_rownames(metadata, var = "CellName")
ERCC_conc <- read.table("C:/Users/besterlab/Dropbox (Technion Dropbox)/Josh/Genome Data Science Course/Final Project/ERCC_concentrations.txt", sep = "\t", header = TRUE, fill = TRUE)
GeneNames <- read.table("C:/Users/besterlab/Dropbox (Technion Dropbox)/Josh/Genome Data Science Course/Final Project/Genenames.txt", sep = "\t", header = TRUE)
GeneNames <- column_to_rownames(GeneNames, var = "Ensembl.Gene.ID")
```

## Normalizing read counts.

### I did this as the authors of the paper did, and in order to have more accurate results I loaded their normalized data instead of subsetting the data for my computer to be able to run it.
```{r filtering and normalizing data, echo = FALSE}
# Split data into biological genes and ERCC spike-ins. 
# ERCC is a universal external control for RNA quality and the authors used it to normalize for the volume in each well, to partially account for batch effect.

bio_genes <- rawdata[which(grepl("ENSMUS", rownames(rawdata))),]
ERCC <- rawdata[which(grepl("ERCC", rownames(rawdata))),]

#Calculating number of ERCC molecules per well
ERCC_num <- matrix(data=NA, nrow=nrow(ERCC_conc), ncol=1)
rownames(ERCC_num) <- rownames(ERCC_conc)
ERCC_num[,1] <- (ERCC_conc[,1]*(10^(-18)))*(6.0221417*(10^23))
ERCC_num_final <- ERCC_num/50000 # dilution factor
ERCC_num_final <- ERCC_num_final * 0.009 # scaling factor

# Scaling reads using RPM, as gene length is not a factor
rpm <- (bio_genes/colSums(bio_genes))*1000000

# Filtering genes to remove cells with less than 2 genes 
cell_count <- apply(rpm, 1, function(n){length(which(n > 20))})
bio_genes_1 <- bio_genes[names(which(cell_count > 2)),]
ERCC_1 <- ERCC[rowSums(ERCC) > 0, ]

# Complete data after filtering and normalizing
Counts <- rbind(bio_genes_1, ERCC_1)
Tech <- c(rep(FALSE, nrow(bio_genes_1)), rep(TRUE, nrow(ERCC_1)))
SpikeInput <- ERCC_num_final[rownames(ERCC_1),1]
SpikeInput_1 <- data.frame("Name" = names(SpikeInput),
                           "Molecules" = SpikeInput,
                           stringsAsFactors = FALSE)

Data <- newBASiCS_Data(as.matrix(Counts), Tech, SpikeInput_1)


# MCMC analysis - I did not do this because my computer took too long to run this function. Instead, I have loaded the normalized counts data from the paper
#MCMC_Output <- BASiCS_MCMC(Data, N = 20000, Thin = 20, 
#                           Burn = 10000, PrintProgress = TRUE, 
#                           Regression = TRUE)
#DenoisedCounts = BASiCS_DenoisedCounts(Data = Data, Chain = MCMC_Output)
```

## Unsupervised machine learning
### PCA
```{r PCA}
# I will try PCA on young vs. old B6 mice in MACS-purified naive cells

MACS <- metadata %>%
  dplyr::filter(Celltype %in% "MACS-purified Naive") %>%
  dplyr::filter(Strain %in% "Mus musculus domesticus")

PCA_Data <- normalized_counts %>%
  dplyr::select(MACS$CellName)

# Filtering for age
Young_B6 <- MACS %>%
  dplyr::filter(Age %in% "Young") %>%
  dplyr::pull(CellName)
Old_B6 <- MACS %>%
  dplyr::filter(Age %in% "Old") %>%
  dplyr::pull(CellName)

# Filtering for activation
Active_pca <- MACS %>%
  dplyr::filter(Stimulus %in% c("Active","Activated")) %>%
  dplyr::pull(CellName)
Unstim_pca <- MACS %>%
  dplyr::filter(Stimulus %in% "Unstimulated") %>%
  dplyr::pull(CellName)

activity_pca <- vector(length = ncol(PCA_Data))
activity_pca [which(grepl(paste(Active_pca, collapse = "|"), colnames(PCA_Data)))] <- "Active"
activity_pca [which(grepl(paste(Unstim_pca, collapse = "|"), colnames(PCA_Data)))] <- "Unstimulated"

age <- vector(length = ncol(PCA_Data))
age [which(grepl(paste(Young_B6, collapse = "|"), colnames(PCA_Data)))] <- "Young"
age [which(grepl(paste(Old_B6, collapse = "|"), colnames(PCA_Data)))] <- "Old"


# Calculating PCA
pca <- prcomp(t(log10(PCA_Data + 1)))
pca.df <- data.frame(pca.1 = pca$x[,1], pca.2 = pca$x[,2], age = age, activity = activity_pca)

# Graph
ggplot(data = pca.df, aes(pca.1, pca.2)) + 
  geom_point(size = 4, mapping = aes(fill = activity, shape = age)) +
  scale_fill_manual(values = c("tomato2", "grey40")) +
  scale_shape_manual(values = c(22,24)) +
  scale_alpha_discrete(range = c(0.5, 1)) +
  theme_minimal() + ylab("PCA 1") + xlab("PCA 2") +
  guides(fill=guide_legend(override.aes=list(shape=21)))

## The only observable clusters are seen between unstimulated and active cells. Old and young cells cluster together. 

```

### tSNE
```{r TSNE}
## I am trying tSNE for old B6 mice vs old castaneus mice in activated, active, and unstimulated cells

# Extracting only young B6 mice
Old <- metadata %>%
  dplyr::filter(Age %in% "Old") %>%
  dplyr::filter(Strain %in% "Mus musculus domesticus")

TSNE_Data <- normalized_counts %>%
  dplyr::select(Old$CellName)

# Filtering each cell type
Cell1 <- Old %>%
  dplyr::filter(Celltype %in% "MACS-purified Naive") %>%
  dplyr::pull(CellName)
Cell2 <- Old %>%
  dplyr::filter(Celltype %in% "FACS-purified Naive") %>%
  dplyr::pull(CellName)
Cell3 <- Old %>%
  dplyr::filter(Celltype %in% "FACS-purified Effector Memory") %>%
  dplyr::pull(CellName)

# Filtering activity
Active_tsne <- Old %>%
  dplyr::filter(Stimulus %in% c("Active","Activated")) %>%
  dplyr::pull(CellName)
Unstim_tsne <- Old %>%
  dplyr::filter(Stimulus %in% "Unstimulated") %>%
  dplyr::pull(CellName)

# Differentiate by cell type and naive vs active
cell_type <- vector(length = ncol(TSNE_Data))
cell_type[which(grepl(paste(Cell1, collapse = "|"), colnames(TSNE_Data)))] <- "MACS-purified Naive" 
cell_type[which(grepl(paste(Cell2, collapse = "|"), colnames(TSNE_Data)))] <- "FACS-purified Naive" 
cell_type[which(grepl(paste(Cell3, collapse = "|"), colnames(TSNE_Data)))] <- "FACS-purified Effector Memory"

activity_tsne <- vector(length = ncol(TSNE_Data))
activity_tsne [which(grepl(paste(Active_tsne, collapse = "|"), colnames(TSNE_Data)))] <- "Active"
activity_tsne [which(grepl(paste(Unstim_tsne, collapse = "|"), colnames(TSNE_Data)))] <- "Unstimulated"

# Calculating tSNE
tsne <- Rtsne(t(log10(TSNE_Data + 1)), perplexity = 10)
tsne.df <- data.frame(tsne.1 = tsne$Y[,1], tsne.2 = tsne$Y[,2], cell_type = cell_type, activity = activity_tsne)

# Plot tSNE
ggplot(data = tsne.df, aes(tsne.1, tsne.2)) + 
  geom_point(size = 4, mapping = aes(fill = cell_type, shape = activity)) +
  scale_fill_manual(values = c("coral4", "tan3", "salmon1")) +
  scale_shape_manual(values = c(21,22)) +
  scale_alpha_discrete(range = c(0.5, 1)) +
  theme_minimal() + ylab("tSNE 1") + xlab("tSNE 2") +
  guides(fill=guide_legend(override.aes=list(shape=21)))

## Unstimulated cells are distinct from active cells, and MACS-purified naive cells were clustered separately from the others.
```

## Correlation plot
```{r corrplot}
# Checking correlation for MACS sorted naive cells in B6 mice only. I am doing a subset so that my computer can run it properly.
MACS <- metadata %>%
  dplyr::filter(Celltype %in% "MACS-purified Naive") %>%
  dplyr::filter(Strain %in% "Mus musculus domesticus")
Corr_counts <- normalized_counts %>%
  dplyr::select(MACS$CellName)

correlationMatrix <- cor(Corr_counts)
ann_col <- MACS %>%
  dplyr::select(CellName, Stimulus, Individuals) %>%
  column_to_rownames(var = "CellName")
# Plotting as a heatmap

pheatmap(correlationMatrix,  
         annotation_col = ann_col, 
         cutree_cols = 3,
         cutree_rows = 3,
         show_rownames = FALSE,
         show_colnames = FALSE)

## The correlations are not very well separated, though unstimulated is mostly separate from active/activated.
```

## Differential expression analysis

```{r DeSeq}
## Checking for differential expression using the raw data. 
## Because we saw that age does not affect the results much, we will focus on the stimulus.

# Filtering out ERCC controls
bio_genes <- rawdata[which(grepl("ENSMUS", rownames(rawdata))),]
# Defining metadata and making sure counts data and coldata are ordered the same. I am also changing "Activated" to "Active" to group them together and make analysis easier.
DESEQ_coldata <- coldata %>%
  dplyr::select(Strain, Stimulus, Celltype) %>%
  dplyr::mutate(Stimulus = replace(Stimulus, Stimulus == "Activated", "Active"))
rownames(DESEQ_coldata) <- sort(rownames(DESEQ_coldata))
colnames(bio_genes) <- sort(colnames(bio_genes))

identical(colnames(bio_genes), rownames(DESEQ_coldata))

# Creating deseq dataset
dds <- DESeqDataSetFromMatrix(countData = bio_genes, 
                              colData = DESEQ_coldata, 
                              design = as.formula("~ Stimulus"))
print(dds)

#Filtering out low information genes
dds <- dds[ rowSums(DESeq2::counts(dds)) > 2, ]
dds <- DESeq(dds)

DEresults <- results(dds, contrast = c("Stimulus", 'Unstimulated', 'Active'),
                     pAdjustMethod = "BH")
# Sort results by increasing p-value
DEresults <- DEresults[order(DEresults$padj),]
print(DEresults)

#MA plot to check normal distribution. Most values should be concentrated at 0 (i.e. most genes are not differentially expressed).
DESeq2::plotMA(object = dds, ylim = c(-5, 5))
#Plot to check that p-values are distributed correctly. I expect to see a peak below 0.1, and approximately uniform distribution above 0.1.
ggplot(data = as.data.frame(DEresults), aes(x = padj)) + 
  geom_histogram(bins = 100) + theme_classic()
```

## Functional enrichment analysis - GO and GSEA
```{r GO and GSEA}
# Using the DE results from the previous analysis
# Removing non-significant values, selecting genes with adjusted p-values < 0.1, and selecting genes with absolute log2 fold change above 1 (two-fold change).
DE <- as.data.frame(DEresults)
DE <- DE %>%
  filter(!is.na(padj)) %>%
  filter(padj < 0.1) %>%
  filter(log2FoldChange >1)

# Obtain names of genes of interest.
genesOfInterest <- rownames(DE)

# GO results
go <- gost(query = genesOfInterest, 
           organism = 'mmusculus', 
           sources = 'GO', correction_method = "fdr",
           evcodes = TRUE)
goResults <- go$result
print(goResults)

## GSEA
# Restrict the terms that have at most 500 genes overlapping with the query
go_top500 <- goResults[goResults$intersection_size < 500,]
# Use the top term from this table to create a gene set 
geneSet1 <- unlist(strsplit(go_top500[1,]$intersection, ','))
# Random 250 genes from the normalized counts
geneSet2 <- sample(rownames(normalized_counts), 250)

geneSets <- list('top_GO_term' = geneSet1,
                 'random_set' = geneSet2)
# Using gage to determine enrichment
gseaResults <- gage(exprs = log2(normalized_counts+1), 
           ref = match(rownames(DESEQ_coldata[DESEQ_coldata$Stimulus == 'Unstimulated',]), 
                       colnames(normalized_counts)), 
           samp = match(rownames(DESEQ_coldata[DESEQ_coldata$Stimulus == 'Active',]), 
                        colnames(normalized_counts)),
           gsets = geneSets, compare = 'as.group')
print(gseaResults$greater)
print(gseaResults$less)
# Therefore, the gene set is significantly upregulated for this GO term, and not downregulated.
```













